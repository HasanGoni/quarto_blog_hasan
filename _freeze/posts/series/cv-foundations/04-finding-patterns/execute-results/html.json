{
  "hash": "d237298cb977f3e56dc66fa31d24b5d6",
  "result": {
    "markdown": "---\ntitle: 'Finding Patterns: Edges, Contours, and Shapes'\nauthor: Hasan\ndate: '2025-01-22'\ncategories:\n  - computer-vision\n  - edge-detection\n  - contours\n  - opencv\ntags:\n  - canny\n  - contours\n  - shapes\n  - pattern-recognition\nimage: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2067&q=80'\ntoc: true\nseries:\n  name: Computer Vision Foundations\n  number: 4\nformat:\n  html: default\n---\n\n## The Detective Story: Teaching Computers to See Patterns\n\nImagine you're a detective looking at a crime scene photo. Your brain instantly picks out:\n- The outline of a footprint in the mud\n- The edge of a broken window\n- The shape of a mysterious object on the table\n\nHow do you do this so effortlessly? You're detecting **edges** and **patterns**â€”the fundamental building blocks of vision.\n\nToday, we're going to teach computers this same superpower. By the end of this post, your computer will be able to find shapes, count objects, and even detect specific patterns in any image!\n\n## The Edge Detection Revolution\n\n**Edges** are where the magic happens. They're the boundaries between different regions in an imageâ€”where one object ends and another begins. Think of them as the \"outlines\" in a coloring book.\n\n### Why Edges Matter\n\nBefore we dive into code, let's understand why edge detection changed everything:\n\n- **Object Recognition**: Edges define object boundaries\n- **Feature Extraction**: Corners and curves are key features\n- **Noise Reduction**: Edges help separate signal from noise\n- **Compression**: JPEG uses edge information to compress images\n\n## Your First Edge Detector: The Canny Algorithm\n\nThe **Canny edge detector** is the gold standardâ€”it's been the go-to algorithm for over 30 years! Here's how it works:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Load and prepare image\nimg = cv2.imread('your_image.jpg')\nimg_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\ngray = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2GRAY)\n\n# Apply Canny edge detection\nedges = cv2.Canny(gray, 50, 150)\n\n# Display the results\nplt.figure(figsize=(15, 5))\n\nplt.subplot(1, 3, 1)\nplt.imshow(img_rgb)\nplt.title(\"Original Image\")\nplt.axis('off')\n\nplt.subplot(1, 3, 2)\nplt.imshow(gray, cmap='gray')\nplt.title(\"Grayscale\")\nplt.axis('off')\n\nplt.subplot(1, 3, 3)\nplt.imshow(edges, cmap='gray')\nplt.title(\"Canny Edges\")\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"Found edges in {np.sum(edges > 0)} pixels out of {edges.size} total pixels\")\n```\n:::\n\n\n**ðŸŽ¯ Try it yourself!** [Open in Colab](https://colab.research.google.com/github/hasanpasha/quarto_blog_hasan/blob/main/notebooks/cv-foundations-04-finding-patterns.ipynb)\n\n### Understanding the Canny Parameters\n\nThe Canny algorithm has two important parametersâ€”think of them as sensitivity controls:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef explore_canny_thresholds(image, low_thresholds, high_thresholds):\n    \"\"\"Explore different Canny threshold combinations\"\"\"\n    gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n    \n    plt.figure(figsize=(15, 10))\n    \n    plot_idx = 1\n    for low in low_thresholds:\n        for high in high_thresholds:\n            edges = cv2.Canny(gray, low, high)\n            \n            plt.subplot(len(low_thresholds), len(high_thresholds), plot_idx)\n            plt.imshow(edges, cmap='gray')\n            plt.title(f\"Low: {low}, High: {high}\")\n            plt.axis('off')\n            \n            plot_idx += 1\n    \n    plt.tight_layout()\n    plt.show()\n\n# Test different threshold combinations\nlow_thresholds = [50, 100, 150]\nhigh_thresholds = [100, 150, 200]\nexplore_canny_thresholds(img_rgb, low_thresholds, high_thresholds)\n```\n:::\n\n\n### The Magic Behind Canny\n\nHere's what happens inside the Canny algorithm (don't worry, OpenCV does this for you!):\n\n1. **Blur** the image to reduce noise\n2. **Calculate gradients** to find intensity changes\n3. **Non-maximum suppression** to thin the edges\n4. **Double thresholding** to classify edge pixels\n5. **Edge tracking** to connect broken edge segments\n\n## From Edges to Shapes: Contour Detection\n\nEdges are great, but **contours** are even better! A contour is a curve that connects all the edge points around an object's boundary. Think of it as tracing around objects with your finger.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Find edges first\ngray = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2GRAY)\nedges = cv2.Canny(gray, 50, 150)\n\n# Find contours\ncontours, hierarchy = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\nprint(f\"Found {len(contours)} contours!\")\n\n# Draw contours on the original image\nimg_with_contours = img_rgb.copy()\ncv2.drawContours(img_with_contours, contours, -1, (0, 255, 0), 2)\n\n# Display results\nplt.figure(figsize=(15, 5))\n\nplt.subplot(1, 3, 1)\nplt.imshow(img_rgb)\nplt.title(\"Original\")\nplt.axis('off')\n\nplt.subplot(1, 3, 2)\nplt.imshow(edges, cmap='gray')\nplt.title(\"Edges\")\nplt.axis('off')\n\nplt.subplot(1, 3, 3)\nplt.imshow(img_with_contours)\nplt.title(f\"Contours ({len(contours)} found)\")\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n### Analyzing Contour Properties\n\nOnce we have contours, we can learn a lot about each shape:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef analyze_contours(contours, image):\n    \"\"\"Analyze properties of each contour\"\"\"\n    img_analysis = image.copy()\n    \n    for i, contour in enumerate(contours):\n        # Calculate contour properties\n        area = cv2.contourArea(contour)\n        perimeter = cv2.arcLength(contour, True)\n        \n        # Skip tiny contours (probably noise)\n        if area < 100:\n            continue\n        \n        # Get bounding rectangle\n        x, y, w, h = cv2.boundingRect(contour)\n        \n        # Calculate aspect ratio\n        aspect_ratio = float(w) / h\n        \n        # Calculate extent (contour area / bounding rectangle area)\n        rect_area = w * h\n        extent = float(area) / rect_area\n        \n        # Draw bounding rectangle\n        cv2.rectangle(img_analysis, (x, y), (x + w, y + h), (255, 0, 0), 2)\n        \n        # Add text with properties\n        text = f\"#{i}: A={int(area)}, AR={aspect_ratio:.2f}\"\n        cv2.putText(img_analysis, text, (x, y-10), \n                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 1)\n        \n        print(f\"Contour {i}:\")\n        print(f\"  Area: {area:.0f} pixels\")\n        print(f\"  Perimeter: {perimeter:.0f} pixels\")\n        print(f\"  Aspect Ratio: {aspect_ratio:.2f}\")\n        print(f\"  Extent: {extent:.2f}\")\n        print()\n    \n    return img_analysis\n\n# Analyze our contours\nanalyzed_img = analyze_contours(contours, img_rgb)\n\nplt.figure(figsize=(12, 8))\nplt.imshow(analyzed_img)\nplt.title(\"Contour Analysis\")\nplt.axis('off')\nplt.show()\n```\n:::\n\n\n## Shape Detection: Teaching Computers Geometry\n\nNow for the really cool partâ€”detecting specific shapes! Let's build a shape classifier:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef classify_shape(contour):\n    \"\"\"Classify a contour as a specific shape\"\"\"\n    # Approximate the contour to reduce number of points\n    epsilon = 0.02 * cv2.arcLength(contour, True)\n    approx = cv2.approxPolyDP(contour, epsilon, True)\n    \n    # Get number of vertices\n    vertices = len(approx)\n    \n    # Calculate aspect ratio\n    x, y, w, h = cv2.boundingRect(contour)\n    aspect_ratio = float(w) / h\n    \n    # Classify based on number of vertices and aspect ratio\n    if vertices == 3:\n        return \"Triangle\"\n    elif vertices == 4:\n        if 0.95 <= aspect_ratio <= 1.05:\n            return \"Square\"\n        else:\n            return \"Rectangle\"\n    elif vertices == 5:\n        return \"Pentagon\"\n    elif vertices > 5:\n        # Check if it's circular\n        area = cv2.contourArea(contour)\n        perimeter = cv2.arcLength(contour, True)\n        circularity = 4 * np.pi * area / (perimeter * perimeter)\n        \n        if circularity > 0.7:\n            return \"Circle\"\n        else:\n            return \"Polygon\"\n    else:\n        return \"Unknown\"\n\ndef detect_shapes(image):\n    \"\"\"Detect and classify shapes in an image\"\"\"\n    # Preprocessing\n    gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n    blurred = cv2.GaussianBlur(gray, (5, 5), 0)\n    edges = cv2.Canny(blurred, 50, 150)\n    \n    # Find contours\n    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    \n    # Classify shapes\n    result_img = image.copy()\n    shape_counts = {}\n    \n    for contour in contours:\n        # Skip small contours\n        if cv2.contourArea(contour) < 500:\n            continue\n        \n        # Classify the shape\n        shape = classify_shape(contour)\n        \n        # Count shapes\n        shape_counts[shape] = shape_counts.get(shape, 0) + 1\n        \n        # Draw contour and label\n        cv2.drawContours(result_img, [contour], -1, (0, 255, 0), 2)\n        \n        # Get centroid for text placement\n        M = cv2.moments(contour)\n        if M[\"m00\"] != 0:\n            cx = int(M[\"m10\"] / M[\"m00\"])\n            cy = int(M[\"m01\"] / M[\"m00\"])\n            cv2.putText(result_img, shape, (cx-30, cy), \n                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)\n    \n    return result_img, shape_counts\n\n# Test shape detection\nshapes_img, shape_counts = detect_shapes(img_rgb)\n\nplt.figure(figsize=(12, 8))\nplt.imshow(shapes_img)\nplt.title(\"Shape Detection Results\")\nplt.axis('off')\nplt.show()\n\nprint(\"Detected shapes:\")\nfor shape, count in shape_counts.items():\n    print(f\"  {shape}: {count}\")\n```\n:::\n\n\n## Real-World Application: Coin Counter\n\nLet's build something practicalâ€”a coin counting system:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef count_coins(image):\n    \"\"\"Count circular objects (coins) in an image\"\"\"\n    # Convert to grayscale\n    gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n    \n    # Apply median blur to reduce noise\n    blurred = cv2.medianBlur(gray, 5)\n    \n    # Use HoughCircles to detect circular objects\n    circles = cv2.HoughCircles(\n        blurred,\n        cv2.HOUGH_GRADIENT,\n        dp=1,\n        minDist=30,\n        param1=50,\n        param2=30,\n        minRadius=10,\n        maxRadius=100\n    )\n    \n    result_img = image.copy()\n    coin_count = 0\n    \n    if circles is not None:\n        circles = np.round(circles[0, :]).astype(\"int\")\n        coin_count = len(circles)\n        \n        # Draw detected circles\n        for (x, y, r) in circles:\n            cv2.circle(result_img, (x, y), r, (0, 255, 0), 2)\n            cv2.circle(result_img, (x, y), 2, (0, 0, 255), 3)\n            cv2.putText(result_img, f\"Coin\", (x-20, y-r-10), \n                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 1)\n    \n    return result_img, coin_count\n\n# Test coin counting (works best with images of coins on a plain background)\ncoins_img, coin_count = count_coins(img_rgb)\n\nplt.figure(figsize=(12, 8))\nplt.imshow(coins_img)\nplt.title(f\"Coin Detection - Found {coin_count} coins\")\nplt.axis('off')\nplt.show()\n```\n:::\n\n\n## Advanced Pattern Detection: Template Matching\n\nSometimes you want to find a specific pattern or object. Template matching is perfect for this:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndef find_template(image, template, threshold=0.8):\n    \"\"\"Find template in image using template matching\"\"\"\n    # Convert both to grayscale\n    gray_img = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n    gray_template = cv2.cvtColor(template, cv2.COLOR_RGB2GRAY)\n    \n    # Perform template matching\n    result = cv2.matchTemplate(gray_img, gray_template, cv2.TM_CCOEFF_NORMED)\n    \n    # Find locations where matching exceeds threshold\n    locations = np.where(result >= threshold)\n    \n    # Draw rectangles around matches\n    result_img = image.copy()\n    h, w = gray_template.shape\n    \n    for pt in zip(*locations[::-1]):  # Switch x and y coordinates\n        cv2.rectangle(result_img, pt, (pt[0] + w, pt[1] + h), (0, 255, 0), 2)\n    \n    return result_img, len(locations[0])\n\n# Create a simple template (you can crop from your image)\n# For demo, let's use a small patch from the original image\ntemplate = img_rgb[50:150, 50:150]  # 100x100 patch\n\nmatched_img, match_count = find_template(img_rgb, template, threshold=0.6)\n\nplt.figure(figsize=(15, 5))\n\nplt.subplot(1, 3, 1)\nplt.imshow(template)\nplt.title(\"Template to Find\")\nplt.axis('off')\n\nplt.subplot(1, 3, 2)\nplt.imshow(img_rgb)\nplt.title(\"Original Image\")\nplt.axis('off')\n\nplt.subplot(1, 3, 3)\nplt.imshow(matched_img)\nplt.title(f\"Matches Found: {match_count}\")\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Building a Complete Object Detection Pipeline\n\nLet's combine everything into a comprehensive object detection system:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nclass SimpleObjectDetector:\n    def __init__(self):\n        self.min_contour_area = 100\n        self.canny_low = 50\n        self.canny_high = 150\n    \n    def preprocess(self, image):\n        \"\"\"Preprocess image for better detection\"\"\"\n        gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n        blurred = cv2.GaussianBlur(gray, (5, 5), 0)\n        return blurred\n    \n    def find_objects(self, image):\n        \"\"\"Find all objects in the image\"\"\"\n        # Preprocess\n        processed = self.preprocess(image)\n        \n        # Edge detection\n        edges = cv2.Canny(processed, self.canny_low, self.canny_high)\n        \n        # Find contours\n        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        \n        # Filter contours by area\n        valid_contours = [c for c in contours if cv2.contourArea(c) > self.min_contour_area]\n        \n        return valid_contours, edges\n    \n    def analyze_objects(self, contours, image):\n        \"\"\"Analyze detected objects\"\"\"\n        results = []\n        result_img = image.copy()\n        \n        for i, contour in enumerate(contours):\n            # Basic properties\n            area = cv2.contourArea(contour)\n            perimeter = cv2.arcLength(contour, True)\n            \n            # Bounding rectangle\n            x, y, w, h = cv2.boundingRect(contour)\n            aspect_ratio = float(w) / h\n            \n            # Shape classification\n            shape = classify_shape(contour)\n            \n            # Store results\n            obj_info = {\n                'id': i,\n                'area': area,\n                'perimeter': perimeter,\n                'aspect_ratio': aspect_ratio,\n                'shape': shape,\n                'bbox': (x, y, w, h)\n            }\n            results.append(obj_info)\n            \n            # Draw on image\n            cv2.drawContours(result_img, [contour], -1, (0, 255, 0), 2)\n            cv2.rectangle(result_img, (x, y), (x + w, y + h), (255, 0, 0), 1)\n            cv2.putText(result_img, f\"{shape} #{i}\", (x, y-10), \n                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 1)\n        \n        return results, result_img\n    \n    def detect(self, image):\n        \"\"\"Complete detection pipeline\"\"\"\n        contours, edges = self.find_objects(image)\n        results, result_img = self.analyze_objects(contours, image)\n        \n        return {\n            'objects': results,\n            'result_image': result_img,\n            'edges': edges,\n            'object_count': len(results)\n        }\n\n# Use the detector\ndetector = SimpleObjectDetector()\ndetection_results = detector.detect(img_rgb)\n\n# Display results\nplt.figure(figsize=(15, 10))\n\nplt.subplot(2, 2, 1)\nplt.imshow(img_rgb)\nplt.title(\"Original Image\")\nplt.axis('off')\n\nplt.subplot(2, 2, 2)\nplt.imshow(detection_results['edges'], cmap='gray')\nplt.title(\"Edge Detection\")\nplt.axis('off')\n\nplt.subplot(2, 2, 3)\nplt.imshow(detection_results['result_image'])\nplt.title(f\"Detected Objects: {detection_results['object_count']}\")\nplt.axis('off')\n\nplt.subplot(2, 2, 4)\n# Create a summary plot\nobject_shapes = [obj['shape'] for obj in detection_results['objects']]\nshape_counts = {}\nfor shape in object_shapes:\n    shape_counts[shape] = shape_counts.get(shape, 0) + 1\n\nif shape_counts:\n    shapes = list(shape_counts.keys())\n    counts = list(shape_counts.values())\n    plt.bar(shapes, counts)\n    plt.title(\"Object Type Distribution\")\n    plt.xticks(rotation=45)\nelse:\n    plt.text(0.5, 0.5, \"No objects detected\", ha='center', va='center', transform=plt.gca().transAxes)\n    plt.title(\"No Objects Found\")\n\nplt.tight_layout()\nplt.show()\n\n# Print detailed results\nprint(\"Detection Results:\")\nprint(f\"Total objects found: {detection_results['object_count']}\")\nprint(\"\\nObject details:\")\nfor obj in detection_results['objects']:\n    print(f\"  Object {obj['id']}: {obj['shape']}\")\n    print(f\"    Area: {obj['area']:.0f} pixels\")\n    print(f\"    Aspect Ratio: {obj['aspect_ratio']:.2f}\")\n    print(f\"    Bounding Box: {obj['bbox']}\")\n```\n:::\n\n\n## Your Challenge: Build a Practical Application\n\nNow it's your turn! Try building one of these applications:\n\n### ðŸŽ¯ **Challenge 1: Document Page Counter**\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndef count_pages(image):\n    \"\"\"Count rectangular pages/documents in an image\"\"\"\n    # Your code here!\n    # Hint: Look for large rectangular contours\n    pass\n```\n:::\n\n\n### ðŸŽ¯ **Challenge 2: Parking Space Detector**\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndef detect_parking_spaces(image):\n    \"\"\"Detect empty parking spaces (rectangular regions)\"\"\"\n    # Your code here!\n    # Hint: Look for rectangular shapes of a certain size\n    pass\n```\n:::\n\n\n### ðŸŽ¯ **Challenge 3: Playing Card Detector**\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndef detect_playing_cards(image):\n    \"\"\"Detect playing cards in an image\"\"\"\n    # Your code here!\n    # Hint: Cards are rectangular with a specific aspect ratio\n    pass\n```\n:::\n\n\n## What's Coming Next?\n\nIn our next adventure, [**\"Feature Magic: What Makes Images Unique\"**](../05-feature-magic/), we'll explore:\n\n- **Keypoint detection** (finding interesting points)\n- **Feature descriptors** (describing what makes each point unique)\n- **Feature matching** (finding the same object in different images)\n- **Panorama stitching** (combining multiple photos)\n\nYou've just learned to find shapes and patternsâ€”next, we'll learn to recognize and match them!\n\n## Key Takeaways\n\n- **Edges are fundamental** to computer vision\n- **Canny edge detection** is the gold standard algorithm\n- **Contours** help us find and analyze shapes\n- **Shape classification** uses geometric properties\n- **Template matching** finds specific patterns\n- **Combining techniques** creates powerful applications\n\n:::{.callout-tip}\n## Hands-On Lab\nReady to detect patterns in your own images? Try the complete interactive notebook: [**Pattern Detection Lab**](https://colab.research.google.com/drive/1Finding_Patterns_Lab_123456)\n\nUpload photos and watch your computer find shapes, count objects, and detect patterns!\n:::\n\n:::{.callout-note}\n## Series Navigation\n- **Previous**: [OpenCV Essentials: Your First Computer Vision Toolkit](../03-opencv-essentials/)\n- **Next**: [Feature Magic: What Makes Images Unique](../05-feature-magic/)\n- **Series Home**: [Computer Vision Foundations](../computer-vision-foundations.qmd)\n:::\n\n---\n\n*You've just taught computers to see patterns and shapes! This is a huge milestoneâ€”you're now working with the same techniques used in industrial quality control, medical imaging, and autonomous vehicles.* \n\n",
    "supporting": [
      "04-finding-patterns_files"
    ],
    "filters": [],
    "includes": {}
  }
}