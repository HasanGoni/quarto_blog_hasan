{
  "hash": "730162501b499101ff1f36110199ab6f",
  "result": {
    "markdown": "---\ntitle: 'Images as Data: How Computers See the World'\nauthor: Hasan\ndate: '2025-01-16'\ncategories:\n  - computer-vision\n  - numpy\n  - matplotlib\n  - basics\ntags:\n  - pixels\n  - arrays\n  - python\n  - hands-on\nimage: 'https://images.unsplash.com/photo-1518709268805-4e9042af2176?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2025&q=80'\ntoc: true\nseries:\n  name: Computer Vision Foundations\n  number: 2\nformat:\n  html: default\n---\n\n## The Great Revelation: Everything is Numbers!\n\nRemember when you first learned that music could be stored as numbers? Or that your favorite movie is just a sequence of 1s and 0s? Well, prepare for another \"mind-blown\" moment: **every image you've ever seen is just a big table of numbers.**\n\nThat sunset photo from your vacation? Numbers. Your profile picture? Numbers. The Mona Lisa? You guessed itâ€”numbers!\n\nLet's dive into this digital rabbit hole and discover how computers really see the world.\n\n## The Pixel Story: Meet the Building Blocks\n\nImagine you're creating a mosaic with tiny colored tiles. Each tile is a single color, and when you step back, all these tiles together form a beautiful picture. In the digital world, these tiles are called **pixels** (short for \"picture elements\").\n\n### Your First Digital Image\n\nLet's create the world's tiniest imageâ€”just 3Ã—3 pixels:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a tiny 3x3 grayscale image\ntiny_image = np.array([\n    [0,   128, 255],\n    [64,  192, 128], \n    [255, 64,  0  ]\n])\n\nprint(\"Our tiny image as numbers:\")\nprint(tiny_image)\nprint(f\"\\nImage shape: {tiny_image.shape}\")\nprint(f\"Image data type: {tiny_image.dtype}\")\n```\n:::\n\n\nNow let's see what this looks like as an actual image:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nplt.figure(figsize=(8, 4))\n\n# Show the numbers\nplt.subplot(1, 2, 1)\nplt.imshow(tiny_image, cmap='gray', interpolation='nearest')\nplt.title(\"What You See\")\nfor i in range(3):\n    for j in range(3):\n        plt.text(j, i, str(tiny_image[i, j]), \n                ha='center', va='center', color='red', fontweight='bold')\nplt.colorbar()\n\n# Show as image\nplt.subplot(1, 2, 2)\nplt.imshow(tiny_image, cmap='gray', interpolation='nearest')\nplt.title(\"Just the Image\")\nplt.colorbar()\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n**ðŸŽ¯ Try this!** [Open in Colab](https://colab.research.google.com/github/hasanpasha/quarto_blog_hasan/blob/main/notebooks/cv-foundations-02-images-as-data.ipynb)\n\n## The Color Mystery: RGB Revealed\n\nBut waitâ€”what about color images? Here's where it gets interesting. Color images are like having three grayscale images stacked on top of each other:\n\n- **Red layer**: How much red is in each pixel\n- **Green layer**: How much green is in each pixel  \n- **Blue layer**: How much blue is in each pixel\n\nThink of it like making a sandwich with three transparent colored sheets!\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# Create a simple 2x2 color image\ncolor_image = np.array([\n    [[255, 0, 0], [0, 255, 0]],      # Red pixel, Green pixel\n    [[0, 0, 255], [255, 255, 0]]     # Blue pixel, Yellow pixel\n])\n\nprint(\"Color image shape:\", color_image.shape)\nprint(\"This means: 2 rows, 2 columns, 3 color channels\")\n\nplt.figure(figsize=(12, 4))\n\n# Show each color channel\nchannels = ['Red', 'Green', 'Blue']\ncolors = ['Reds', 'Greens', 'Blues']\n\nfor i in range(3):\n    plt.subplot(1, 4, i+1)\n    plt.imshow(color_image[:, :, i], cmap=colors[i])\n    plt.title(f\"{channels[i]} Channel\")\n    plt.axis('off')\n\n# Show the combined image\nplt.subplot(1, 4, 4)\nplt.imshow(color_image)\nplt.title(\"Combined RGB\")\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Loading Your First Real Image\n\nEnough with toy examples! Let's load a real photograph and explore it:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport cv2\n\n# Load an image (you can upload your own to Colab!)\nimg = cv2.imread('sample_image.jpg')\n\n# OpenCV loads images in BGR format, let's convert to RGB\nimg_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\nprint(f\"Image shape: {img_rgb.shape}\")\nprint(f\"Image size: {img_rgb.size} pixels\")\nprint(f\"Data type: {img_rgb.dtype}\")\n\n# Display the image\nplt.figure(figsize=(10, 6))\nplt.imshow(img_rgb)\nplt.title(\"Your First Real Image!\")\nplt.axis('off')\nplt.show()\n\n# Let's examine a small patch\npatch = img_rgb[100:110, 100:110]  # 10x10 pixel patch\nprint(f\"\\nA small 10x10 patch from the image:\")\nprint(f\"Shape: {patch.shape}\")\nprint(f\"First pixel RGB values: {patch[0, 0]}\")\n```\n:::\n\n\n## The Magic of Image Operations\n\nNow that we understand images as numbers, we can do mathematical operations on them! This is where the fun begins.\n\n### Making Images Brighter or Darker\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Load and prepare image\nimg = cv2.imread('sample_image.jpg')\nimg_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\n# Make it brighter (add to all pixels)\nbrighter = np.clip(img_rgb + 50, 0, 255).astype(np.uint8)\n\n# Make it darker (subtract from all pixels)  \ndarker = np.clip(img_rgb - 50, 0, 255).astype(np.uint8)\n\n# Show the results\nplt.figure(figsize=(15, 5))\n\nplt.subplot(1, 3, 1)\nplt.imshow(darker)\nplt.title(\"Darker (-50)\")\nplt.axis('off')\n\nplt.subplot(1, 3, 2)\nplt.imshow(img_rgb)\nplt.title(\"Original\")\nplt.axis('off')\n\nplt.subplot(1, 3, 3)\nplt.imshow(brighter)\nplt.title(\"Brighter (+50)\")\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n### Playing with Individual Color Channels\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# Create different color effects\nred_only = img_rgb.copy()\nred_only[:, :, 1] = 0  # Remove green\nred_only[:, :, 2] = 0  # Remove blue\n\ngreen_only = img_rgb.copy()\ngreen_only[:, :, 0] = 0  # Remove red\ngreen_only[:, :, 2] = 0  # Remove blue\n\nblue_only = img_rgb.copy()\nblue_only[:, :, 0] = 0  # Remove red\nblue_only[:, :, 1] = 0  # Remove green\n\n# Display the results\nplt.figure(figsize=(15, 5))\n\nplt.subplot(1, 3, 1)\nplt.imshow(red_only)\nplt.title(\"Red Channel Only\")\nplt.axis('off')\n\nplt.subplot(1, 3, 2)\nplt.imshow(green_only)\nplt.title(\"Green Channel Only\")\nplt.axis('off')\n\nplt.subplot(1, 3, 3)\nplt.imshow(blue_only)\nplt.title(\"Blue Channel Only\")\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## The Grayscale Transformation\n\nConverting to grayscale is one of the most common operations in computer vision. But it's not just about averaging the RGB valuesâ€”there's a secret formula!\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Method 1: Simple average (not the best)\ngray_simple = np.mean(img_rgb, axis=2).astype(np.uint8)\n\n# Method 2: Weighted average (the right way!)\n# Human eyes are more sensitive to green, less to blue\ngray_weighted = (0.299 * img_rgb[:, :, 0] + \n                0.587 * img_rgb[:, :, 1] + \n                0.114 * img_rgb[:, :, 2]).astype(np.uint8)\n\n# Method 3: Using OpenCV (does the weighted average for us)\ngray_opencv = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\nplt.figure(figsize=(15, 5))\n\nplt.subplot(1, 3, 1)\nplt.imshow(gray_simple, cmap='gray')\nplt.title(\"Simple Average\")\nplt.axis('off')\n\nplt.subplot(1, 3, 2)\nplt.imshow(gray_weighted, cmap='gray')\nplt.title(\"Weighted Average\")\nplt.axis('off')\n\nplt.subplot(1, 3, 3)\nplt.imshow(gray_opencv, cmap='gray')\nplt.title(\"OpenCV Method\")\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Fun with Image Arithmetic\n\nSince images are just arrays, we can do all sorts of mathematical operations:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Create a simple pattern\nrows, cols = img_rgb.shape[:2]\nx_gradient = np.linspace(0, 255, cols).astype(np.uint8)\ny_gradient = np.linspace(0, 255, rows).astype(np.uint8)\n\n# Create gradient patterns\nhorizontal_gradient = np.tile(x_gradient, (rows, 1))\nvertical_gradient = np.tile(y_gradient.reshape(-1, 1), (1, cols))\n\nplt.figure(figsize=(15, 5))\n\nplt.subplot(1, 3, 1)\nplt.imshow(horizontal_gradient, cmap='gray')\nplt.title(\"Horizontal Gradient\")\nplt.axis('off')\n\nplt.subplot(1, 3, 2)\nplt.imshow(vertical_gradient, cmap='gray')\nplt.title(\"Vertical Gradient\")\nplt.axis('off')\n\n# Combine gradients\ncombined = (horizontal_gradient + vertical_gradient) // 2\nplt.subplot(1, 3, 3)\nplt.imshow(combined, cmap='gray')\nplt.title(\"Combined Gradients\")\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Your First Image Filter: The Blur Effect\n\nLet's create a simple blur effect by averaging neighboring pixels:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndef simple_blur(image, kernel_size=5):\n    \"\"\"Apply a simple blur by averaging neighboring pixels\"\"\"\n    blurred = np.zeros_like(image)\n    offset = kernel_size // 2\n    \n    for i in range(offset, image.shape[0] - offset):\n        for j in range(offset, image.shape[1] - offset):\n            # Average the pixels in the kernel area\n            neighborhood = image[i-offset:i+offset+1, j-offset:j+offset+1]\n            blurred[i, j] = np.mean(neighborhood)\n    \n    return blurred\n\n# Apply our blur to a grayscale image\ngray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\nblurred_img = simple_blur(gray_img)\n\nplt.figure(figsize=(12, 6))\n\nplt.subplot(1, 2, 1)\nplt.imshow(gray_img, cmap='gray')\nplt.title(\"Original\")\nplt.axis('off')\n\nplt.subplot(1, 2, 2)\nplt.imshow(blurred_img, cmap='gray')\nplt.title(\"Our Custom Blur\")\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## The Big Picture: What We've Learned\n\nðŸŽ‰ **Congratulations!** You've just unlocked one of the most important concepts in computer vision. Here's what you now know:\n\n1. **Images are arrays of numbers** (0-255 for each pixel)\n2. **Grayscale images** are 2D arrays (height Ã— width)\n3. **Color images** are 3D arrays (height Ã— width Ã— 3 channels)\n4. **Image processing** is just mathematical operations on these arrays\n5. **You can create effects** by manipulating pixel values\n\n## Practical Exercises\n\nBefore moving to the next post, try these fun experiments:\n\n### ðŸŽ¯ **Exercise 1: Create Your Own Pattern**\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# Create a checkerboard pattern\nsize = 200\ncheckerboard = np.zeros((size, size))\nsquare_size = 25\n\nfor i in range(0, size, square_size):\n    for j in range(0, size, square_size):\n        if (i // square_size + j // square_size) % 2 == 0:\n            checkerboard[i:i+square_size, j:j+square_size] = 255\n\nplt.imshow(checkerboard, cmap='gray')\nplt.title(\"Checkerboard Pattern\")\nplt.axis('off')\nplt.show()\n```\n:::\n\n\n### ðŸŽ¯ **Exercise 2: Image Negative**\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# Create a negative effect (like old film negatives)\nnegative = 255 - img_rgb\n\nplt.figure(figsize=(12, 6))\nplt.subplot(1, 2, 1)\nplt.imshow(img_rgb)\nplt.title(\"Original\")\nplt.axis('off')\n\nplt.subplot(1, 2, 2)\nplt.imshow(negative)\nplt.title(\"Negative\")\nplt.axis('off')\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## What's Coming Next?\n\nIn our next adventure, [**\"OpenCV Essentials: Your First Computer Vision Toolkit\"**](../03-opencv-essentials/), we'll:\n\n- Master the essential OpenCV functions\n- Learn to resize, crop, and rotate images like a pro\n- Build our first interactive image viewer\n- Create a simple photo editor\n\nThe best part? Everything we've learned about images as numbers will make OpenCV operations crystal clear!\n\n## Key Takeaways\n\n- **Images = Numbers**: Every pixel is just a number (or three numbers for color)\n- **Shape Matters**: Always check `image.shape` to understand your data\n- **Math is Magic**: Simple arithmetic creates powerful visual effects\n- **Start Simple**: Complex algorithms are built from these basic operations\n\n:::{.callout-tip}\n## Hands-On Practice\nReady to experiment? Try the full interactive notebook: [**Images as Data - Interactive Lab**](https://colab.research.google.com/drive/1AbCdEfGhIjKlMnOpQrStUvWxYz123456)\n\nUpload your own photos and see them transform into numbers!\n:::\n\n:::{.callout-note}\n## Series Navigation\n- **Previous**: [Why Computer Vision?](../01-why-computer-vision/)\n- **Next**: [OpenCV Essentials: Your First Computer Vision Toolkit](../03-opencv-essentials/)  \n- **Series Home**: [Computer Vision Foundations](../computer-vision-foundations.qmd)\n:::\n\n---\n\n*Remember: You've just learned to see the world the way computers do. That's no small feat! In the next post, we'll use this knowledge to build amazing things with OpenCV.* \n\n",
    "supporting": [
      "02-images-as-data_files"
    ],
    "filters": [],
    "includes": {}
  }
}