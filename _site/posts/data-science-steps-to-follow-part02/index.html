<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Hasan Goni">
<meta name="dcterms.date" content="2022-11-20">

<title>Hasan Blog Post - Data Science Steps to Follow -02</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-listing/list.min.js"></script>
<script src="../../site_libs/quarto-listing/quarto-listing.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>

  window.document.addEventListener("DOMContentLoaded", function (_event) {
    const listingTargetEl = window.document.querySelector('#listing-listing .list');
    if (!listingTargetEl) {
      // No listing discovered, do not attach.
      return; 
    }

    const options = {
      valueNames: ['listing-categories',{ data: ['index'] },{ data: ['categories'] },{ data: ['listing-date-sort'] },{ data: ['listing-file-modified-sort'] }],
      
      searchColumns: ["listing-categories"],
    };

    window['quarto-listings'] = window['quarto-listings'] || {};
    window['quarto-listings']['listing-listing'] = new List('listing-listing', options);

    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  });

  window.addEventListener('hashchange',() => {
    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  })
  </script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Hasan Blog Post</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://hasangoni.quarto.pub/hasan-blog-post/" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/HasanGoni" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/hasangoni" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-page-left">
      <h1 class="title">Data Science Steps to Follow -02</h1>
            <p class="subtitle lead">Feature preprocessing and generation</p>
                                <div class="quarto-categories">
                <div class="quarto-category">code</div>
                <div class="quarto-category">tabular</div>
                <div class="quarto-category">analysis</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Hasan Goni </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 20, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    <h5 class="quarto-listing-category-title">Categories</h5><div class="quarto-listing-category category-default"><div class="category" data-category="">All <span class="quarto-category-count">(0)</span></div></div></div>
<!-- main -->
<main class="content quarto-banner-title-block column-page-left" id="quarto-document-content">




<section id="feature-preprocessing-and-generation" class="level1">
<h1>Feature Preprocessing and Generation</h1>
<ul>
<li>This is a second part of the class note of how to proceed to a data science project. First part can be found <a href="https://Hasangoni.github.io/2022/11/19/Explanatory_data_analysis.html">here</a>. In this part I will try to write down, how prprocessing steps vary based on model selection. What type of preprocessing needs to be done on different types of data and how to handle missing values in a project.</li>
</ul>
</section>
<section id="employed-model-impacts-choice-of-preprocessing" class="level1">
<h1>Employed model impacts choice of preprocessing</h1>
<ul>
<li>Normally if we have a model non linear dependency between features and target, we should use one type of preprocessing
<ul>
<li>for example one hot encoding</li>
<li>however random forest is not sensitive to one hot encoding and doesnot require it</li>
</ul></li>
<li>Feature generation sometimes gives you a peak in performance
<ul>
<li>for example if you have a feature which is a combination of two features, it can give you a peak in performance</li>
<li>however it is not always the case, sometimes it can give you a dip in performance</li>
<li>so it is always good to try out feature generation and see if it gives you a peak in performance</li>
</ul></li>
<li>Depends on the model you are using and the type of data you have you need to choose the type of preprocessing(feature preprocessing and feature generation)
<ul>
<li>for example if you are using a linear model, you should use one hot encoding</li>
<li>if you are using a tree based model, you should not use one hot encoding</li>
</ul></li>
</ul>
</section>
<section id="feature-preporocessings-and-feature-generation" class="level1">
<h1>Feature preporocessings and feature generation</h1>
<section id="numeric-features" class="level2">
<h2 class="anchored" data-anchor-id="numeric-features">Numeric features</h2>
<section id="prprocessing" class="level3">
<h3 class="anchored" data-anchor-id="prprocessing">Prprocessing</h3>
<ul>
<li><p>Model Types</p>
<ul>
<li>Tree based models
<ul>
<li>Normally if features are multiplied with some numbers, then model performance doesnot change, thats Noralization doesnot necessary for tree based models</li>
</ul></li>
<li>Non-tree based models
<ul>
<li>But in case of non tree based model scaling and normalization can affect the model</li>
<li>Some non tree based models are
<ul>
<li>k nearest neighbors</li>
<li>linear models</li>
<li>nueral networks</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>Preprocessing: Scaling</p>
<ul>
<li><p>To[0, 1] sklearn.preprocessing.MinMaxScaler <span class="math display">\[ X = (X - X.min()) / (X.max() - X.min()) \]</span></p></li>
<li><p>To [mean=0 std=1] sklearn.preprocessing.StandardScaler <span class="math display">\[ X = (X - X.mean()) / X.std() \]</span></p></li>
</ul></li>
<li><p>Preprocessing: Outliers</p>
<ul>
<li><p>Can be found both in features and outputs</p></li>
<li><p>If outliers are present in features, then we can use robust scaler</p></li>
<li><p>We can also use lower bound and upper bound between two values, may be 0.01 and 0.99 percentile, well known in finance called <strong>winsorization</strong></p>
<ul>
<li><code>python     UPPER_BOUND, LOWER_BOUND = np.percentile(X, [1, 99])     y = np.clip(y, UPPER_BOUND, LOWER_BOUND)     pd.Series(y).hist(bins=30)</code></li>
</ul></li>
<li><p>Another way to preprocess is rank transformation, which actually sets spaces between proper assorted values to to equal, it could be a better option from MInMaxScaler, if we have outliers in features, because rank transformation will move the outlier to closer to object</p>
<ul>
<li><p>Linear models, neural networks, k nearest neighbors can benefits from this, if we have no times to handle outliers manually</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   scipy.stats.rankdata</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>One important things about rank transformaiton, when applying to test data, you need to store the created mapping from feature values to rank values. Or alternatively you can concatenate train and test data and apply rank transformation to the whole dataset, and then split it back to train and test</p></li>
</ul></li>
</ul></li>
<li><p>Preprocessing: Transformation</p>
<ul>
<li>There is one more preprocessing which often helps to non tree based models, specially neural networks.
<ul>
<li><p>It is called log transformation</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  np.log(<span class="dv">1</span> <span class="op">+</span> X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Or Raising to power &lt;1:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  np.sqrt(X, <span class="dv">2</span><span class="op">/</span><span class="dv">3</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Both this transformations could be helpful, because they drive too big values closer to features average value, so values near 0 a bit distuinguishable. Despite simplicity, this transformation could be helpful in many cases for neural network. <strong>Also data seems to be normllay distributed after this transformation (if not try to use other transformation and see histogram[Andrew ng])</strong></p></li>
</ul></li>
<li><strong>Sometimes it is benefecial to apply concatenated dataframes produced be different preprocessing, or to mix models training different pre-porcessed data. Specially Linear models, KNN and Neural networks can benefit from this</strong></li>
</ul></li>
</ul>
</section>
<section id="feature-generation" class="level3">
<h3 class="anchored" data-anchor-id="feature-generation">Feature generation</h3>
<ul>
<li>Ways to proceed :
<ul>
<li><p>prior knowledge</p></li>
<li><p>EDA(exploratory data analysis)</p></li>
<li><p>Example:</p>
<ul>
<li>We have Real state price and real state squared data, from this we can create a new feature which is price per square meter</li>
<li>Forest cover type prediction dataset, if we have horizontal and vertical distance from hydrology, we can create a new feature which is distance from hydrology, <span class="math display">\[ combined = \sqrt{horizontal\_distance\_to\_hydrology^2 + vertical\_distance\_to\_hydrology^2} \]</span></li>
</ul>
<p>This type of featur generation is not only helpful for neural network and linear models, but also for tree based models, sometimes we can have a peak in performance with less amount of trees with thiess type of feature generation</p>
<ul>
<li>Another example is, if we have a price of a product, we can take fraction of the price. for example if the price is 9.99 the fractionaly part of the price is 0.99. This type of feature of features also can distinguish between robot and human. Normally in finance, this is very helpful. As a human we normally use whole number.</li>
</ul></li>
<li><p>This is just some example, one can be very creative and can get a peak in model performance with feature generation</p></li>
</ul></li>
</ul>
</section>
</section>
<section id="categorical-and-ordinal-features" class="level2">
<h2 class="anchored" data-anchor-id="categorical-and-ordinal-features">Categorical and Ordinal features</h2>
<section id="preprocessing" class="level3">
<h3 class="anchored" data-anchor-id="preprocessing">Preprocessing</h3>
<ul>
<li><p>In Titanice dataset, caegorical features are Sex, Cabin and Embarked and ordinal features are Pclass, which stands for passenger class. We have a value [1,2,3] for PClas, which is ordered based on the price of the ticket, so it is ordinal feature.</p></li>
<li><p>One needs to be very careful here, because if we put PClass as a numeric features, we say the difference between class 1 and class 2 is the same as the difference between class 2 and class 3, which is not true.</p></li>
<li><p>Other ordinal features are</p>
<ul>
<li>Driver’s license: A, B, C, D, E, F, G</li>
<li>Education: Elementary, Middle, High, College, Master, PhD</li>
</ul></li>
<li><p>For Ordinal features one can use LabelEncoder, which will assign a number to each category, but it will not be ordered, so we need to use OrdinalEncoder, In case of tree based models, such model helps, but in case of non tree based models, you need to use the preprocess the data in a different way.</p></li>
<li><p>For Titanic dataset again, let’s see the Embarked feature, which has category S, C, Q.</p>
<ul>
<li><p>Alphabetical : [S, C, Q] -&gt; [2, 1, 3]</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  <span class="im">from</span> sklearn.preprocessing <span class="im">import</span> LabelEncoder</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  le <span class="op">=</span> LabelEncoder()</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  le.fit_transform(df[<span class="st">'Embarked'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Order of apperance:</p>
<p>[S, C, Q] -&gt; [1, 2, 3] S comes first to the data and C comes after that</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>pandas.factorize</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>Frequency Encodeing: [S, C, Q] -&gt; [0.5, 0.3, 0.2] S is the most frequent category and Q is the least frequent category</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>encoding <span class="op">=</span> df.groupby(<span class="st">'Embarked'</span>).size() <span class="op">/</span> <span class="bu">len</span>(df)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'enc'</span>] <span class="op">=</span> df[<span class="st">'Embarked'</span>].<span class="bu">map</span>(encoding)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>One important thing regarding frequency encoding, if we have multiple features with same frequency, then the features are not distinguishable, so we need to rank transformation</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>encoding <span class="op">=</span> df.groupby(<span class="st">'Embarked'</span>).size() <span class="op">/</span> <span class="bu">len</span>(df)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'enc'</span>] <span class="op">=</span> df[<span class="st">'Embarked'</span>].<span class="bu">map</span>(encoding)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> rankdata</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div></li>
<li><p>There are different encodings possible, one can be very creative here, one need to try different encodings here.</p></li>
<li><p>Categorical features for non-tree based models</p>
<ul>
<li>One hot encoding</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>pd.get_dummies, sklearn.preprocessing.OneHotEncoder</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>Tree methods will slow down here, because they will have to split on each category, so one hot encoding is not good for tree based models</li>
<li>If too many unique categories, then one hot encoding will create too many features, To work with them we need to know how to handle sparse data.XGBoost, LightGBM, CatBoost can handle sparse data, but other models cannot handle sparse data, so we need to use some other methods to handle sparse data.</li>
</ul></li>
</ul></li>
</ul>
</section>
<section id="feature-generation-1" class="level3">
<h3 class="anchored" data-anchor-id="feature-generation-1">Feature generation</h3>
<ul>
<li>Feature interaction between several categorica features -&gt; normally usefull linear model and KNN, e.g.&nbsp;Titanic dataset, sex and Pclass. We can concatenate both features and then one hot encode them. Advanced feature generation will be discussed in the next sections.</li>
</ul>
</section>
</section>
<section id="datetime-and-coordinates" class="level2">
<h2 class="anchored" data-anchor-id="datetime-and-coordinates">Datetime and coordinates</h2>
<section id="feature-generationdatetime" class="level3">
<h3 class="anchored" data-anchor-id="feature-generationdatetime">Feature generation:Datetime</h3>
<ul>
<li><p>Most of the time, we have a datetime feature, which is a string, we need to convert it to a datetime object, so we can extract different features from it, such as year, month, day, hour, minute, second, day of week, day of year, week of year, quarter, etc.</p></li>
<li><p>Normally it falls into three categories</p>
<ul>
<li><p>Peridocity: year, month, day, hour, minute, second, day of week, day of year, week of year, quarter, etc.</p>
<ul>
<li>helpful to capture repetative patterns in the data</li>
</ul></li>
<li><p>Time Since:</p>
<ul>
<li>Row independent moment, e.g.&nbsp;time since last purchase, time since last login, time since last visit, day since lasth holiday, day to next holiday, etc.</li>
<li>Row dependent moment, e.g.&nbsp;since 00:00:00 UTC, 1 January 1970, etc.</li>
</ul></li>
<li><p>Difference between dates:</p>
<ul>
<li>datetime_feature_1 - datretime_feature_2. e.g.&nbsp;churn prediciton. The likelihood, the customers will churn. feature: last_purchase_date, last_call_date, date_diff = last_purchase_date - last_call_date</li>
</ul></li>
<li><p>After generating features in datetime, we will get numeric or categorical features, so we need to apply the same preprocessing as we did for numeric and categorical features.</p></li>
</ul></li>
</ul>
</section>
<section id="feature-generation-coordinates" class="level3">
<h3 class="anchored" data-anchor-id="feature-generation-coordinates">Feature generation: Coordinates</h3>
<ul>
<li>Distance:
<ul>
<li>Real state price prediction. We can create new features to calculate distance from the city center, distance from the airport, distance from the sea, etc. If such data is not available we can extract some features from the maps. We can convert the map into differnt squares and extract the most expensive flats in this square and then calculate the distance from the center of the square. We can also use the same method to calculate the distance from the airport, sea, etc.
<ul>
<li>Create cluster from datapoints and calculate the center of the cluster and then calculate the distance from the center of the cluster.</li>
<li>Find some very special areas and add distance from these areas.</li>
</ul></li>
</ul></li>
<li>Aggreagated statistics, objects sorrounding area:
<ul>
<li>Calcualte number of important place in sorrounding area, which can be interpreted as the quality of the area.</li>
<li>Or mean price of the sorrounding area. How expensive sorrounding area is.</li>
</ul></li>
<li>In case of decision trees, slightyl rotated coordinates can be helpful, because decision trees are not able to capture the rotation of the data.</li>
</ul>
</section>
</section>
<section id="missing-values" class="level2">
<h2 class="anchored" data-anchor-id="missing-values">Missing Values</h2>
<ul>
<li><p>Examples of missing values</p>
<ul>
<li>NA Values</li>
<li>Empty string</li>
<li>-1</li>
<li>Very large number</li>
<li>-99999 (or less)</li>
<li>999</li>
<li>99</li>
</ul></li>
<li><p>how to know, whether this is a missing value or not. plot histogram, and see some values are very different from other values, So missing values can be hidden means may be used other values in plac of missing values.</p></li>
<li><p>Fillna approaches:</p></li>
</ul>
<ol type="1">
<li>-999, -1 etc -&gt; for Neural networks it will be difficult</li>
<li>mean, median, mode -&gt; for trees it will be harder to find differnt splits</li>
<li>Reconsturct value</li>
</ol>
<ul>
<li><p>Feature generation:</p></li>
<li><p>Need to create a new column named as is_missing, which will be 1 if the value is missing and 0 if the value is not missing. This will help the model to capture the missing values. -&gt; help both tree an neural networks but only problem is number of columns will increated</p></li>
<li><p>Carful during missing value imputation, e.g.&nbsp;we have two features, one is datetime and temperature of whole year. If we impute the missing values with mean, then the mean will be calculated from the whole year, which is not correct, because the temperature is not same in the whole year. So we need to calculate the mean for each month and then impute the missing values with the mean of the month. Then we creeate a new feature, which will be the difference between the mean of the month and the actual value. In case of imputation with mean, it will be 0, as we already impute it with mean, which is 0 , so new feature will not create some sense, or in other way new feature will not help the model. So we need to be careful during imputation. <strong>Unfortunately we don’t have enough time to be careful here</strong>.</p></li>
<li><p>For example we have a categorical featue, we have created a numeric feature from this categorical feature. So A-&gt;1, B-&gt;9, B-&gt;?, if we impute missing value with some outer range value like -999 in missing value. Then the category will be going to closer to -999 and the more missing value and category will go more closer to this big or small number. In case of mean and median imputation it will also a problem. So we need to be careful during imputation. <strong>Simple solution will be ignore missing value, while calculating the mean and median</strong>.</p></li>
<li><p>XGBoost, LightGBM, CatBoost can handle missing values.</p></li>
<li><p>Sometimes outliers can be handled as missing values.</p></li>
<li><p>Treat missing values which appeear in test but not in trainig data.</p>
<ul>
<li>Create a category which will tell how frequently occures this category. If there is some correlation between occurence frequeny and target, then it will sucessly tell the prediction.</li>
</ul></li>
</ul>
<section id="summray-missing-values" class="level3">
<h3 class="anchored" data-anchor-id="summray-missing-values">Summray missing values</h3>
<ul>
<li>The choice of filling depends on situation</li>
<li>Usual way -999, mean, median, mode but careful</li>
<li>Missing values sometimes hidden.</li>
<li>Binary feature is_missing is helpful</li>
<li>avoid missing values during feature generation</li>
<li>XGBoost can handle missing values</li>
</ul>
<p><strong>Next post can be found <a href="https://Hasangoni.github.io/2022/11/19/Exploring_anonymized_data.html">here</a></strong></p>



</section>
</section>
</section>

<div class="quarto-listing quarto-listing-container-default" id="listing-listing">
<div class="list quarto-listing-default">

</div>
<div class="listing-no-matching d-none">
No matching items
</div>
</div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>